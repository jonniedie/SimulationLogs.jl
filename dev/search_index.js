var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#SimulationLogs.SimulationLogs","page":"API","title":"SimulationLogs.SimulationLogs","text":"SimulationLogs\n\nLog internal variables in a DifferentialEquations.jl simulation with the @log macro and use the get_log function to retrieve the logged variables.\n\n\n\n\n\n","category":"module"},{"location":"api/#SimulationLogs.Logged","page":"API","title":"SimulationLogs.Logged","text":"struct Logged{T,N,A,S<:AbstractTimeseriesSolution{T,N,A}} <: AbstractTimeseriesSolution{T,N,A}\n\nLogged(sol::AbstractTimeseriesSolution, log::SimulationLog)\n\nLogged differential equation solution. All properties of the underlying solution can be accessed with the getproperty or 'dot' accessing. The inner SimulationLog can be accessed with .log. A Logged solution can be used the same way as its underlying solution (i.e. indexed with sol[i] and interpolated with sol(t))\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationLogs.SimulationLog","page":"API","title":"SimulationLogs.SimulationLog","text":"SimulationLog(; value_dict::Dict{Symbol,Vector}=Dict{Symbol,Vector}(), is_active::Bool=false)\n\nA log of saved variables from a simulation. Variables can be accessed with dot notation or the getproperty function.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationLogs.activate!","page":"API","title":"SimulationLogs.activate!","text":"activate!(log::SimulationLog=GLOBAL_LOG)\n\nActivate a SimulationLog. If no log is given, activate the GLOBAL_LOG.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationLogs.deactivate!","page":"API","title":"SimulationLogs.deactivate!","text":"deactivate!(log::SimulationLog=GLOBAL_LOG)\n\nDeactivate a SimulationLog. If no log is given, deactivate the GLOBAL_LOG.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationLogs.get_log-Tuple{Any}","page":"API","title":"SimulationLogs.get_log","text":"get_log(sol; callback=nothing)\nget_log(sol, t; callback=nothing)\n\nGet the variables logged by @log from an ODESolution. If a callback or callback set was used to change parameters during the simulation, it must be passed in through the keyword callback to obtain correct results. When doing this, be sure to reset any parameters that changed over the course of the simulation to their starting values.\n\nAlternatively, replace your solve call with logged_solve to handle this all automatically.\n\nSee also: logged_solve\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationLogs.is_active-Tuple{SimulationLog}","page":"API","title":"SimulationLogs.is_active","text":"is_active(log::SimulationLog)\n\nSee if simulation is currently active (able to be logged to).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationLogs.logged_solve-Tuple{Any, Vararg{Any}}","page":"API","title":"SimulationLogs.logged_solve","text":"logged_solve(prob, args...; kwargs...)\n\nCreate a Logged ODE solution whose logged variables can be accessed through the .log property.\n\nSee also: get_log\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationLogs.reset!","page":"API","title":"SimulationLogs.reset!","text":"reset!(log::SimulationLog=GLOBAL_LOG)\n\nReset the value dictionary of a SimulationLog. If no log is given, the GLOBAL_LOG will be reset\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationLogs.scope","page":"API","title":"SimulationLogs.scope","text":"scope(sol, varnames)\nscope!(sol, varnames)\n\nPlot the variables in varnames from an ODESolution sol. If varnames is a vector, the variables will be plotted against time on the same axis. If varnames is a tuple, the variables will be plotted against each other.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationLogs.scope!","page":"API","title":"SimulationLogs.scope!","text":"scope(sol, varnames)\nscope!(sol, varnames)\n\nPlot the variables in varnames from an ODESolution sol. If varnames is a vector, the variables will be plotted against time on the same axis. If varnames is a tuple, the variables will be plotted against each other.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationLogs.value_dict-Tuple{SimulationLog}","page":"API","title":"SimulationLogs.value_dict","text":"value_dict(log::SimulationLog)\n\nGet the value dictionary of a SimulationLog.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationLogs.@log-Tuple{Any}","page":"API","title":"SimulationLogs.@log","text":"@log var_name = val\n@log var_name expr\n\nLog var_name to the GLOBAL_LOG. If @log is placed on an assignment for var_name, the variable will also be created in the local scope. If @log is placed with a variable name before an expression, the expression will run in the local scope without creating the variable in that scope.\n\nExample\n\nfunction lorenz!(du, u, p, t)\n    @log a = u[2]-u[1]\n    @log b u[3]+a\n    du[1] = p[1]*a\n    du[2] = u[1]*(p[2]-u[3]) - u[2]\n    du[3] = u[1]*u[2] - p[3]*u[3]\nend\n\nIn this example, a is evaluated into the scope of the lorenz! function and is able to be used within that scope. b, however is not evaluated into the lorenz! scope, so no b variable is created in that scope. Both a and b will be logged.\n\n\n\n\n\n","category":"macro"},{"location":"examples/cruise_control/#Cruise-Control","page":"Cruise Control","title":"Cruise Control","text":"","category":"section"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"Let's see how we can use SimulationLogs for a typical controls simulation.","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"First, we'll start with a simple model of a car using ComponentArrays.jl,  DifferentialEquations.jl, and UnPack.jl.","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"using ComponentArrays\nusing DifferentialEquations\nusing UnPack\n\n# Simple car with velocity-square drag\nfunction car!(D, x, p, t; u=0.0)\n    @unpack pos, vel = x\n    @unpack c, m = p\n\n    drag = c*vel^2\n    D.pos = vel\n    D.vel = (-drag*sign(vel) + u)/m\nend\n\ncar_params = (\n    m = 1000,\n    c = 5,\n)\n\ncar_ic = ComponentArray(\n    pos = 0.0,\n    vel = 0.0,\n)","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"Now this is a pretty boring simulation; the car is just going to sit there. Let's add a cruise control system to the car so it will track a velocity setpoint. We'll use a proportional-integral (PI) controller to follow a reference step input.","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"# Car with cruise control\nfunction cruise_car!(D, vars, p, t)\n    @unpack ref, kp, ki = p.control\n    @unpack ∫e, car = vars\n\n    r = ref(t)\n    e = r - car.vel\n    u = kp*e + ki*∫e\n    \n    car!(D.car, car, p.car, t; u)\n    D.∫e = e\nend\n\n# Parameters\np = (\n    car = car_params,\n    control = (\n        ref = t -> 10*(t>1),\n        kp = 800,\n        ki = 40,\n    )\n)\n\n# Initial conditions\nic = ComponentArray(\n    car = car_ic,\n    ∫e = 0.0,\n)\n\nprob = ODEProblem(cruise_car!, ic, (0.0, 20.0), p)\nsol = solve(prob)","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"Now we can bring in the Plots.jl library to look at our velocity.","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"using Plots\n\nplot(sol, vars=2, title=\"Velocity\", legend=false)","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"(Image: )","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"Great. There's our velocity. But what if we want to plot the velocity against the reference signal r? Or what if we want to plot the reference tracking error e, control signal u, or even the drag force drag?","category":"page"},{"location":"examples/cruise_control/#Enter-SimulationLogs","page":"Cruise Control","title":"Enter SimulationLogs","text":"","category":"section"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"using SimulationLogs","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"Using SimulationLogs, we can tag any variable we'd like to see with the @log macro. So adding that to our simulation functions would look like:","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"function car!(D, x, p, t; u=0.0)\n    @unpack pos, vel = x\n    @unpack c, m = p\n\n    @log drag = c*vel^2\n    D.pos = vel\n    D.vel = (-drag*sign(vel) + u)/m\nend\n\nfunction cruise_car!(D, vars, p, t)\n    @unpack ref, kp, ki = p.control\n    @unpack ∫e, car = vars\n\n    @log r = ref(t)\n    @log e = r - car.vel\n    @log u = kp*e + ki*∫e\n    \n    car!(D.car, car, p.car, t; u)\n    D.∫e = e\nend","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"Now we can re-run our simulation and use the scope function to plot the outputs.","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"sol = solve(prob)\n\np1 = plot(sol, vars=2, title=\"Reference Tracking\")\nscope!(sol, :r)\n\np2 = scope(sol, [:u, :drag], title=\"Forces\")\n\np3 = plot(sol, vars=3, title=\"Errors\")\nscope!(sol, :e)\n\nplot(p1, p2, p3, layout=(3,1), size=(600,600))","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"(Image: )","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"If we want to get our logged variables (not just plot them), we can use the get_log function.","category":"page"},{"location":"examples/cruise_control/","page":"Cruise Control","title":"Cruise Control","text":"julia> logsout = get_log(sol)\nSimulationLog with signals:\n  drag :: Float64\n  e :: Float64\n  u :: Float64\n  r :: Int64\n\n\njulia> logsout.drag\n33-element Vector{Float64}:\n   0.0\n   0.0\n   0.0\n   0.0\n   ⋮\n 498.74065942087725\n 498.94149067684566\n 499.10812257810085\n 499.1675529889568","category":"page"},{"location":"#SimulationLogs.jl","page":"Home","title":"SimulationLogs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimulationLogs lets you log variables from within a DifferentialEquations.jl ODE simulation.","category":"page"},{"location":"#The-Basics","page":"Home","title":"The Basics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To log a variable, use the @log macro before an existing variable declaration in the simulation. The syntax for this looks like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@log x = u[1]+u[3]","category":"page"},{"location":"","page":"Home","title":"Home","text":"To log an expression to an output variable without creating that variable in the simulation use the following syntax:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@log x u[1]+u[3]","category":"page"},{"location":"","page":"Home","title":"Home","text":"To extract logged values from a simulation, use the get_log function.","category":"page"}]
}
